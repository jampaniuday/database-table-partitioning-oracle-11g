set serveroutput on;
set pagesize 1000;
set linesize 1000;

-- delclare variables that will use to determine which versions need to be partitioned.
DECLARE
  v5check  number := 0;
  v6check  number := 0;
  v7check  number := 0;
BEGIN

select count(*) into v5check from user_tables where table_name='PERFORMANCE_SAMPLE_PAR';
select count(*) into v6check from user_tables where table_name='VMWP_SAMPLE_PAR';
select count(*) into v7check from user_tables where table_name='NET_DP_SAMPLE_PAR';
-- NOTE: THIS MUST BE DONE IN THE FOLLOWING ORDER:
-- 1. CREATE NEW SAMPLE TABLE (BUT NONE OF THE DEPENDENTS)
-- 2. CONVERT SAMPLE TABLE
-- 3. CREATE DEPENDENT (SUB) TABLES
-- 4. CONVERT DEPENDENT (SUB) TABLES

-- Convert SAMPLE tables to Partitioned Tables --
if v5check = 1 then

DBMS_OUTPUT.put_line('Starting v5 table partitioning');

DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_SAMPLE', 'PERFORMANCE_SAMPLE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_SAMPLE', 'PERFORMANCE_SAMPLE_PAR');

-- Cleanup data --
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_SAMPLE', cascade => TRUE);

DBMS_OUTPUT.put_line('Performance Sample partitioned');

DBMS_OUTPUT.put_line('Creating Partition tables for reference partition tables (performance_* tables)');
------------------------------------
-- Start of PERFORMANCE_AGGREGATE --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_AGGREGATE_PAR (
"SAMPLE_ID" NUMBER(20) NOT NULL, 
"CPU_USR" FLOAT(126), 
"CPU_SYS" FLOAT(126), 
"CPU_WIO" FLOAT(126), 
"FREE_MEM" FLOAT(126), 
"FREE_SWAP" FLOAT(126), 
"RUN_QUEUE" FLOAT(126), 
"RUN_OCC" FLOAT(126), 
"READ_CACHE" FLOAT(126), 
"WRITE_CACHE" FLOAT(126), 
"PG_OUT_SEC" FLOAT(126), 
"PPG_OUT_SEC" FLOAT(126), 
"PG_FREE_SEC" FLOAT(126), 
"PG_SCAN_SEC" FLOAT(126), 
"ATCH_SEC" FLOAT(126), 
"PG_IN_SEC" FLOAT(126), 
"PPG_IN_SEC" FLOAT(126), 
"PFLT_SEC" FLOAT(126), 
"VFLT_SEC" FLOAT(126), 
"SLOCK_SEC" FLOAT(126), 
"NUM_PROCS" NUMBER(20), 
"PROC_READ" FLOAT(126), 
"PROC_WRITE" FLOAT(126), 
"PROC_BLOCK" FLOAT(126), 
"DNLC" FLOAT(126), 
"FORK_SEC" FLOAT(126), 
"EXEC_SEC" FLOAT(126), 
"TCP_RETRANS" NUMBER(20), 
"WORST_DISK_USAGE" NUMBER(20), 
"WORST_DISK_BUSY" NUMBER(20), 
"USED_SWAP_PERCENT" NUMBER(20), 
PRIMARY KEY (SAMPLE_ID) VALIDATE, 
CONSTRAINT FK_AGGREGATE FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_AGGREGATE)';

------------------------------------
-- Start of PERFORMANCE_CPU --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_CPU_PAR( 
"ID" NUMBER(20), 
"CPU_ID" NUMBER(20), 
"CPU_USR" NUMBER(20), 
"CPU_SYS" NUMBER(20), 
"CPU_WIO" NUMBER(20), 
"XCAL" NUMBER(20), 
"INTR" NUMBER(20), 
"SMTX" NUMBER(20), 
"MINF" FLOAT(126), 
"MJF" FLOAT(126), 
"ITHR" FLOAT(126), 
"CSW" FLOAT(126), 
"ICSW" FLOAT(126), 
"MIGR" FLOAT(126), 
"SRW" FLOAT(126), 
"SYSCL" FLOAT(126), 
"IDLE" FLOAT(126), 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
PRIMARY KEY ("ID") VALIDATE,
CONSTRAINT FK_CPU FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_CPU)';

------------------------------------
-- Start of PERFORMANCE_DISK --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_DISK_PAR ( 
"ID" NUMBER(20), 
"DISK_NAME" VARCHAR2(255), 
"PCT_TIME_BUSY" NUMBER(20), 
"AVG_QUEUE_REQ" NUMBER(20), 
"RW_SEC" NUMBER(20), 
"BLOCKS_SEC" NUMBER(20), 
"AVG_WAIT_TIME" NUMBER(20), 
"AVG_SERV_TIME" NUMBER(20), 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
PRIMARY KEY ("ID") VALIDATE ,
CONSTRAINT FK_DISK FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_DISK)';

------------------------------------
-- Start of PERFORMANCE_DISK_TOTAL --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_DISK_TOTAL_PAR (
"SAMPLE_ID" NUMBER(20) NOT NULL, 
"PCT_TIME_BUSY" NUMBER(20), 
"AVG_QUEUE_REQ" NUMBER(20), 
"RW_SEC" NUMBER(20), 
"BLOCKS_SEC" NUMBER(20), 
"AVG_WAIT_TIME" NUMBER(20), 
"AVG_SERV_TIME" NUMBER(20), 
PRIMARY KEY ("SAMPLE_ID") VALIDATE,
CONSTRAINT FK_DISK_TOTAL FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE
) 
PARTITION BY REFERENCE (FK_DISK_TOTAL)';

------------------------------------
-- Start of PERFORMANCE_ESX3_WORKLOAD --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_ESX3_WORKLOAD_PAR ( 
"ID" NUMBER(20), 
"UUID" VARCHAR2(255), 
"INSTANCE_NAME" VARCHAR2(255), 
"CPU_USAGE_MHZ" NUMBER(20), 
"MEMORY" NUMBER(20), 
"DISK_IO_RATE" NUMBER(20), 
"NETWORK_IO_RATE" NUMBER(20), 
"PERCENT_READY" FLOAT(126), 
"PERCENT_USED" FLOAT(126), 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
PRIMARY KEY ("ID") VALIDATE ,
CONSTRAINT FK_ESX3 FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_ESX3)';

------------------------------------
-- Start of PERFORMANCE_FSCAP --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_FSCAP_PAR ( 
"ID" NUMBER(20), 
"FILESYSTEM" VARCHAR2(255), 
"TOTAL_SIZE" NUMBER(20), 
"SPACE_USED" NUMBER(20), 
"SPACE_AVAIL" NUMBER(20), 
"PERCENT_USED" NUMBER(20), 
"MOUNT_POINT" VARCHAR2(255), 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
PRIMARY KEY ("ID") VALIDATE,
CONSTRAINT FK_FSCAP FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_FSCAP)';

------------------------------------
-- Start of PERFORMANCE_LPAR_WORKLOAD --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_LPAR_WORKLOAD_PAR ( 
"ID" NUMBER(20), 
"LPAR_ID" NUMBER(20), 
"INSTANCE_NAME" VARCHAR2(255), 
"ENTITLEMENT" FLOAT(126), 
"CPU_USAGE" FLOAT(126), 
"USED_MEMORY" NUMBER(20), 
"NETWORK_IO_RATE" NUMBER(20), 
"DISK_IO_RATE" NUMBER(20), 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
PRIMARY KEY ("ID") VALIDATE, 
CONSTRAINT FK_LPAR FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_LPAR)';

------------------------------------
-- Start of PERFORMANCE_NETWORK --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_NETWORK_PAR ( 
"ID" NUMBER(20), 
"IFACE_NAME" VARCHAR2(255), 
"IN_BYTES" NUMBER(20), 
"OUT_BYTES" NUMBER(20), 
"COLLISIONS" NUMBER(20), 
"IN_ERRORS" NUMBER(20), 
"OUT_ERRORS" NUMBER(20), 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
PRIMARY KEY ("ID") VALIDATE, 
CONSTRAINT FK_NETWORK FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_NETWORK)';

------------------------------------
-- Start of PERFORMANCE_NRM --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_NRM_PAR ( 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
"WORK_TO_DO" NUMBER(20), 
"AVAILABLE_DISK" NUMBER(20), 
"DS_THREAD_USAGE" NUMBER(20), 
"ALLOCATED_SERVER_PROCS" NUMBER(20), 
"AVAILABLE_SERVER_PROCS" NUMBER(20), 
"PACKET_RECEIVE_BUFFERS" NUMBER(20), 
"AVAILABLE_ECBS" NUMBER(20), 
"LAN_TRAFFIC" NUMBER(20), 
"CONNECTION_USAGE" NUMBER(20), 
"DISK_THROUGHPUT" NUMBER(20), 
"ABENDED_THREAD_COUNT" NUMBER(20), 
PRIMARY KEY ("SAMPLE_ID") VALIDATE, 
CONSTRAINT FK_NRM FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_NRM)';

------------------------------------
-- Start of PERFORMANCE_PSINFO --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_PSINFO_PAR ( 
"ID" NUMBER(20), 
"PID" NUMBER(20), 
"PPID" NUMBER(20), 
"PS_UID" VARCHAR2(255), 
"GID" VARCHAR2(255), 
"MEM_USED" NUMBER(20), 
"RSS" NUMBER(20), 
"CPU_USAGE" FLOAT(126), 
"MEMORY_USAGE" FLOAT(126), 
"USER_CPU_TIME" NUMBER(20), 
"SYS_CPU_TIME" NUMBER(20), 
"START_TIME" TIMESTAMP(6), 
"PROC_NAME" VARCHAR2(255), 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
PRIMARY KEY ("ID") VALIDATE, 
CONSTRAINT FK_PSINFO FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_PSINFO)';

------------------------------------
-- Start of PERFORMANCE_VXVOL --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_VXVOL_PAR ( 
"ID" NUMBER(20), 
"DG" VARCHAR2(255), 
"VOL" VARCHAR2(255), 
"RD_OPS" NUMBER(20), 
"WR_OPS" NUMBER(20), 
"RD_BLKS" NUMBER(20), 
"WR_BLKS" NUMBER(20), 
"AVG_RD" NUMBER(20), 
"AVG_WR" NUMBER(20), 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
PRIMARY KEY ("ID") VALIDATE, 
CONSTRAINT FK_VXVOL FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_VXVOL)';

------------------------------------
-- Start of PERFORMANCE_WHO --
------------------------------------
-- With Reference Partitioning --
EXECUTE IMMEDIATE 'CREATE TABLE PERFORMANCE_WHO_PAR ( 
"ID" NUMBER(20), 
"USERNAME" VARCHAR2(255), 
"SESSION_COUNT" NUMBER(20), 
"SAMPLE_ID" NUMBER(20) NOT NULL, 
PRIMARY KEY ("ID") VALIDATE, 
CONSTRAINT FK_WHO FOREIGN KEY (SAMPLE_ID) 
  REFERENCES PERFORMANCE_SAMPLE (ID) VALIDATE 
)
PARTITION BY REFERENCE (FK_WHO)';

DBMS_OUTPUT.put_line('Completed reference partition table creation');

DBMS_OUTPUT.put_line('Starting conversion of reference partition tables');
-- Convert to Partitioned Table --
DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_AGGREGATE', 'PERFORMANCE_AGGREGATE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_AGGREGATE', 'PERFORMANCE_AGGREGATE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_AGGREGATE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_AGGREGATE', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_CPU', 'PERFORMANCE_CPU_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_CPU', 'PERFORMANCE_CPU_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_CPU_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_CPU', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_DISK', 'PERFORMANCE_DISK_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_DISK', 'PERFORMANCE_DISK_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_DISK_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_DISK', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_DISK_TOTAL', 'PERFORMANCE_DISK_TOTAL_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_DISK_TOTAL', 'PERFORMANCE_DISK_TOTAL_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_DISK_TOTAL_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_DISK_TOTAL', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_ESX3_WORKLOAD', 'PERFORMANCE_ESX3_WORKLOAD_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_ESX3_WORKLOAD', 'PERFORMANCE_ESX3_WORKLOAD_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_ESX3_WORKLOAD_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_ESX3_WORKLOAD', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_FSCAP', 'PERFORMANCE_FSCAP_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_FSCAP', 'PERFORMANCE_FSCAP_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_FSCAP_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_FSCAP', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_LPAR_WORKLOAD', 'PERFORMANCE_LPAR_WORKLOAD_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_LPAR_WORKLOAD', 'PERFORMANCE_LPAR_WORKLOAD_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_LPAR_WORKLOAD_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_LPAR_WORKLOAD', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_NETWORK', 'PERFORMANCE_NETWORK_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_NETWORK', 'PERFORMANCE_NETWORK_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_NETWORK_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_NETWORK', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_NRM', 'PERFORMANCE_NRM_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_NRM', 'PERFORMANCE_NRM_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_NRM_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_NRM', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_PSINFO', 'PERFORMANCE_PSINFO_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_PSINFO', 'PERFORMANCE_PSINFO_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_PSINFO_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_PSINFO', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_VXVOL', 'PERFORMANCE_VXVOL_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_VXVOL', 'PERFORMANCE_VXVOL_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_VXVOL_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_VXVOL', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'PERFORMANCE_WHO', 'PERFORMANCE_WHO_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'PERFORMANCE_WHO', 'PERFORMANCE_WHO_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_WHO_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'PERFORMANCE_WHO', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'ERDC_INT_DATA', 'ERDC_INT_DATA_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'ERDC_INT_DATA', 'ERDC_INT_DATA_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE ERDC_INT_DATA_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'ERDC_INT_DATA', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'ERDC_DECIMAL_DATA', 'ERDC_DECIMAL_DATA_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'ERDC_DECIMAL_DATA', 'ERDC_DECIMAL_DATA_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE ERDC_DECIMAL_DATA_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'ERDC_DECIMAL_DATA', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'ERDC_STRING_DATA', 'ERDC_STRING_DATA_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'ERDC_STRING_DATA', 'ERDC_STRING_DATA_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE ERDC_STRING_DATA_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'ERDC_STRING_DATA', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'RANGED_OBJECT_VALUE', 'RANGED_OBJECT_VALUE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'RANGED_OBJECT_VALUE', 'RANGED_OBJECT_VALUE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE RANGED_OBJECT_VALUE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'RANGED_OBJECT_VALUE', cascade => TRUE);

DBMS_OUTPUT.put_line('Completed conversion of reference tables');

DBMS_OUTPUT.put_line('Starting Index creation');

-- performance_sample --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_S_UPTIMEHOST_ID 
ON PERFORMANCE_SAMPLE ("UPTIMEHOST_ID")';
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_S_ERDC_ID
ON PERFORMANCE_SAMPLE ("ERDC_ID")';
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_S_LATEST_SAMPLE
ON PERFORMANCE_SAMPLE ("ERDC_ID", "SAMPLE_TIME")';

EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_S_SAMPLE_BY_HOST
ON PERFORMANCE_SAMPLE ("UPTIMEHOST_ID", "SAMPLE_TIME")';


-- performance_aggregate --
-- no indexes necessary

-- performance_cpu --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_C_SAMPLE_ID 
ON PERFORMANCE_CPU ("SAMPLE_ID")';


-- performance_disk --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_D_SAMPLE_ID 
ON PERFORMANCE_DISK ("SAMPLE_ID")';


-- performance_disk_total --
-- no indexes necessary

-- performance_esx3_workload --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_E_SAMPLE_ID 
ON PERFORMANCE_ESX3_WORKLOAD ("SAMPLE_ID")';


-- performance_fscap --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_F_SAMPLE_ID 
ON PERFORMANCE_FSCAP ("SAMPLE_ID")';


-- performance_lpar_worload --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_L_SAMPLE_ID 
ON PERFORMANCE_LPAR_WORKLOAD ("SAMPLE_ID")';


-- performance_network --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_NET_SAMPLE_ID 
ON PERFORMANCE_NETWORK ("SAMPLE_ID")';


-- performance_nrm --
--default index

-- performance_psinfo --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_P_SAMPLE_ID 
ON PERFORMANCE_PSINFO ("SAMPLE_ID")';


-- performance_vxvol --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_V_SAMPLE_ID 
ON PERFORMANCE_VXVOL ("SAMPLE_ID")';


-- performance_who --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_W_SAMPLE_ID 
ON PERFORMANCE_WHO ("SAMPLE_ID")';


-- erdc_int_data --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_ERDC_INT
ON ERDC_INT_DATA ("ERDC_PARAMETER_ID", "ERDC_INSTANCE_ID", "SAMPLETIME")';


-- erdc_decimal_data --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_ERDC_DECIMAL
ON ERDC_DECIMAL_DATA ("ERDC_PARAMETER_ID", "ERDC_INSTANCE_ID", "SAMPLETIME")';


-- erdc_string_data --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_ERDC_STRING
ON ERDC_STRING_DATA ("ERDC_PARAMETER_ID", "ERDC_INSTANCE_ID", "SAMPLETIME")';


-- ranged_object_value --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_RANGED_OBJECT_ID
ON RANGED_OBJECT_VALUE ("RANGED_OBJECT_ID")';

EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_RANGED_OBJECT_NAME
ON RANGED_OBJECT_VALUE ("NAME")';

DBMS_OUTPUT.put_line('Completed index creation');

DBMS_OUTPUT.put_line('Drop temp performance sample table');
EXECUTE IMMEDIATE 'DROP TABLE PERFORMANCE_SAMPLE_PAR CASCADE CONSTRAINTS PURGE';

DBMS_OUTPUT.put_line('End of v5 table partitioning');
else 
DBMS_OUTPUT.put_line('No partition table for v5 so skipping partitioning those tables');
end if;


if v6check = 1 then

DBMS_OUTPUT.put_line('Starting v6 table partitioning');

DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_SAMPLE', 'VMWP_SAMPLE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_SAMPLE', 'VMWP_SAMPLE_PAR');
-- Cleanup data --
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_SAMPLE', cascade => TRUE);

DBMS_OUTPUT.put_line('vmware_perf_sample partitioned');
DBMS_OUTPUT.put_line('Creating Partition tables for reference partition tables (vmware_perf_* tables)');

EXECUTE IMMEDIATE 'CREATE TABLE VMWP_AGGREGATE_PAR (
"SAMPLE_ID" NUMBER(20) NOT NULL,
"CPU_RESERVATION" NUMBER(20),
"CPU_USAGE" NUMBER(20),
"CPU_TOTAL" NUMBER(20),
"DISK_USAGE" NUMBER(20),
"MEMORY_RESERVATION" NUMBER(20),
"MEMORY_USAGE" NUMBER(20),
"MEMORY_TOTAL" NUMBER(20),
"NETWORK_USAGE" NUMBER(20),
CONSTRAINT "FK_VM_AGG" FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_VM_AGG)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_CLUSTER_PAR" (
"SAMPLE_ID" NUMBER(20) NOT NULL,
"FAILOVER" NUMBER(20),
CONSTRAINT "FK_CLUSTER"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_CLUSTER)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_DATASTORE_USAGE_PAR" (
"SAMPLE_ID" NUMBER(20) NOT NULL,
"CAPACITY" NUMBER(20),
"PROVISIONED" NUMBER(20),
"USAGE_TOTAL" NUMBER(20),
"USAGE_VM_DISK" NUMBER(20),
"USAGE_SNAPSHOT" NUMBER(20),
"USAGE_SWAP" NUMBER(20),
"USAGE_OTHER_VM" NUMBER(20),
"USAGE_OTHER" NUMBER(20),
CONSTRAINT "FK_DATASTORE_USAGE"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_DATASTORE_USAGE)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_DATASTORE_VM_USAGE_PAR" ( 
"ID" NUMBER(20),
"SAMPLE_ID" NUMBER(20) NOT NULL,
"VIRTUAL_MACHINE_ID" NUMBER(20),
"USAGE_TOTAL" NUMBER(20),
CONSTRAINT "FK_DATASTORE_VM_USAGE"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_DATASTORE_VM_USAGE)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_DISK_RATE_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"READ_RATE" NUMBER(20),
"WRITE_RATE" NUMBER(20),
CONSTRAINT "FK_DISK_RATE"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_DISK_RATE)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_ENTITLEMENT_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"CPU" NUMBER(20),
"MEMORY" NUMBER(20),
CONSTRAINT "FK_ENTITLEMENT"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_ENTITLEMENT)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_HOST_CPU_PAR" ( 
"ID" NUMBER(20),
"SAMPLE_ID" NUMBER(20) NOT NULL,
"CPU_ID" NUMBER(20),
"CPU_PERCENT_USAGE" NUMBER(20),
CONSTRAINT "FK_HOST_CPU"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_HOST_CPU)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_HOST_DISK_IO_PAR" ( 
"ID" NUMBER(20),
"SAMPLE_ID" NUMBER(20) NOT NULL,
"DISK_ID" VARCHAR2(255),
"READ_LATENCY" NUMBER(20),
"WRITE_LATENCY" NUMBER(20),
"TOTAL_LATENCY" NUMBER(20),
"READ_RATE" NUMBER(20),
"WRITE_RATE" NUMBER(20),
CONSTRAINT "FK_HOST_DISK"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_HOST_DISK)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_HOST_DISK_IO_ADV_PAR" (
"ID" NUMBER(20),
"SAMPLE_ID" NUMBER(20) NOT NULL,
"DISK_ID" VARCHAR2(255),
"BUS_RESETS" NUMBER(20),
"COMMANDS_ABORTED" NUMBER(20),
"DEVICE_LATENCY" NUMBER(20),
"DEVICE_READ_LATENCY" NUMBER(20),
"DEVICE_WRITE_LATENCY" NUMBER(20),
"KERNEL_LATENCY" NUMBER(20),
"KERNEL_READ_LATENCY" NUMBER(20),
"KERNEL_WRITE_LATENCY" NUMBER(20),
"QUEUE_LATENCY" NUMBER(20),
"QUEUE_READ_LATENCY" NUMBER(20),
"QUEUE_WRITE_LATENCY" NUMBER(20),
"READ_COUNT" NUMBER(20),
"WRITE_COUNT" NUMBER(20),
CONSTRAINT "FK_HOST_DISK_ADV"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_HOST_DISK_ADV)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_HOST_NETWORK_PAR" ( 
"ID" NUMBER(20),
"SAMPLE_ID" NUMBER(20) NOT NULL,
"NIC_ID" VARCHAR2(255),
"RECEIVE_RATE" NUMBER(20),
"RECEIVE_DROPPED" NUMBER(20),
"TRANSMIT_RATE" NUMBER(20),
"TRANSMIT_DROPPED" NUMBER(20),
CONSTRAINT "FK_HOST_NETWORK"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_HOST_NETWORK)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_HOST_POWER_STATE_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"POWERED_ON" NUMBER(10),
"POWERED_OFF" NUMBER(10),
"MAINTENANCE" NUMBER(10),
"STANDBY" NUMBER(10),
"UNKNOWN" NUMBER(10),
CONSTRAINT "FK_HOST_POWER"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_HOST_POWER)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_MEM_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"ACTIVE" NUMBER(20),
"BALLOONED" NUMBER(20),
"GRANTED" NUMBER(20),
CONSTRAINT "FK_VM_MEM"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_VM_MEM)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_MEM_ADVANCED_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"OVERHEAD" NUMBER(20),
"SHARED" NUMBER(20),
"SHARED_COMMON" NUMBER(20),
"SWAP_RATE_IN" NUMBER(20),
"SWAP_RATE_OUT" NUMBER(20),
"SWAP_USED" NUMBER(20),
"ZERO" NUMBER(20),
CONSTRAINT "FK_VM_MEM_ADV"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_VM_MEM_ADV)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_NETWORK_RATE_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"RECEIVE_RATE" NUMBER(20),
"TRANSMIT_RATE" NUMBER(20),
CONSTRAINT "FK_NETWORK_RATE"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_NETWORK_RATE)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_VM_CPU_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"READY" NUMBER(20),
"WAIT" NUMBER(20),
"CPU_PERCENT_USAGE" NUMBER(20),
CONSTRAINT "FK_VM_CPU"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_VM_CPU)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_VM_DISK_IO_PAR" ( 
"ID" NUMBER(20),
"SAMPLE_ID" NUMBER(20) NOT NULL,
"DISK_ID" VARCHAR2(255),
"BUS_RESETS" NUMBER(20),
"COMMANDS_ABORTED" NUMBER(20),
"READ_COUNT" NUMBER(20),
"READ_RATE" NUMBER(20),
"WRITE_COUNT" NUMBER(20),
"WRITE_RATE" NUMBER(20),
CONSTRAINT "FK_VM_DISK"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_VM_DISK)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_VM_NETWORK_PAR" ( 
"ID" NUMBER(20),
"SAMPLE_ID" NUMBER(20) NOT NULL,
"NIC_ID" VARCHAR2(255),
"RECEIVE_RATE" NUMBER(20),
"TRANSMIT_RATE" NUMBER(20),
CONSTRAINT "FK_VM_NETWORK"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_VM_NETWORK)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_VM_POWER_STATE_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"POWERED_ON" NUMBER(10),
"POWERED_OFF" NUMBER(10),
"SUSPENDED" NUMBER(10),
CONSTRAINT "FK_VM_POWER"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_VM_POWER)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_VM_STORAGE_USAGE_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"PROVISIONED" NUMBER(20),
"DISK" NUMBER(20),
"SNAPSHOT" NUMBER(20),
"SWAP" NUMBER(20),
"OTHER" NUMBER(20),
CONSTRAINT "FK_VM_STORAGE"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_VM_STORAGE)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_VM_VCPU_PAR" ( 
"ID" NUMBER(20),
"SAMPLE_ID" NUMBER(20) NOT NULL,
"CPU_ID" NUMBER(20),
"CPU_USAGE" NUMBER(20),
"SYSTEM" NUMBER(20),
"WAIT" NUMBER(20),
"USED" NUMBER(20),
CONSTRAINT "FK_VM_VCPU"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_VM_VCPU)';


EXECUTE IMMEDIATE 'CREATE TABLE "VMWP_WATTS_PAR" ( 
"SAMPLE_ID" NUMBER(20) NOT NULL,
"WATTS" NUMBER(20),
CONSTRAINT "FK_VM_WATTS"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES VMWARE_PERF_SAMPLE ("SAMPLE_ID") VALIDATE ,
PRIMARY KEY ("SAMPLE_ID") VALIDATE )
PARTITION BY REFERENCE (FK_VM_WATTS)';

DBMS_OUTPUT.put_line('Completed reference partition table creation');
DBMS_OUTPUT.put_line('Starting conversion of reference partition tables');


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_AGGREGATE', 'VMWP_AGGREGATE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_AGGREGATE', 'VMWP_AGGREGATE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_AGGREGATE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_AGGREGATE', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_CLUSTER', 'VMWP_CLUSTER_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_CLUSTER', 'VMWP_CLUSTER_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_CLUSTER_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_CLUSTER', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_DATASTORE_USAGE', 'VMWP_DATASTORE_USAGE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_DATASTORE_USAGE', 'VMWP_DATASTORE_USAGE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_DATASTORE_USAGE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_DATASTORE_USAGE', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_DATASTORE_VM_USAGE', 'VMWP_DATASTORE_VM_USAGE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_DATASTORE_VM_USAGE', 'VMWP_DATASTORE_VM_USAGE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_DATASTORE_VM_USAGE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_DATASTORE_VM_USAGE', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_DISK_RATE', 'VMWP_DISK_RATE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_DISK_RATE', 'VMWP_DISK_RATE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_DISK_RATE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_DISK_RATE', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_ENTITLEMENT', 'VMWP_ENTITLEMENT_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_ENTITLEMENT', 'VMWP_ENTITLEMENT_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_ENTITLEMENT_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_ENTITLEMENT', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_HOST_CPU', 'VMWP_HOST_CPU_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_HOST_CPU', 'VMWP_HOST_CPU_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_HOST_CPU_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_HOST_CPU', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_HOST_DISK_IO', 'VMWP_HOST_DISK_IO_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_HOST_DISK_IO', 'VMWP_HOST_DISK_IO_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_HOST_DISK_IO_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_HOST_DISK_IO', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_HOST_DISK_IO_ADV', 'VMWP_HOST_DISK_IO_ADV_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_HOST_DISK_IO_ADV', 'VMWP_HOST_DISK_IO_ADV_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_HOST_DISK_IO_ADV_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_HOST_DISK_IO_ADV', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_HOST_NETWORK', 'VMWP_HOST_NETWORK_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_HOST_NETWORK', 'VMWP_HOST_NETWORK_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_HOST_NETWORK_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_HOST_NETWORK', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_HOST_POWER_STATE', 'VMWP_HOST_POWER_STATE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_HOST_POWER_STATE', 'VMWP_HOST_POWER_STATE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_HOST_POWER_STATE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_HOST_POWER_STATE', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_MEM', 'VMWP_MEM_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_MEM', 'VMWP_MEM_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_MEM_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_MEM', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_MEM_ADVANCED', 'VMWP_MEM_ADVANCED_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_MEM_ADVANCED', 'VMWP_MEM_ADVANCED_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_MEM_ADVANCED_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_MEM_ADVANCED', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_NETWORK_RATE', 'VMWP_NETWORK_RATE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_NETWORK_RATE', 'VMWP_NETWORK_RATE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_NETWORK_RATE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_NETWORK_RATE', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_VM_CPU', 'VMWP_VM_CPU_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_VM_CPU', 'VMWP_VM_CPU_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_VM_CPU_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_VM_CPU', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_VM_DISK_IO', 'VMWP_VM_DISK_IO_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_VM_DISK_IO', 'VMWP_VM_DISK_IO_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_VM_DISK_IO_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_VM_DISK_IO', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_VM_NETWORK', 'VMWP_VM_NETWORK_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_VM_NETWORK', 'VMWP_VM_NETWORK_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_VM_NETWORK_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_VM_NETWORK', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_VM_POWER_STATE', 'VMWP_VM_POWER_STATE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_VM_POWER_STATE', 'VMWP_VM_POWER_STATE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_VM_POWER_STATE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_VM_POWER_STATE', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_VM_STORAGE_USAGE', 'VMWP_VM_STORAGE_USAGE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_VM_STORAGE_USAGE', 'VMWP_VM_STORAGE_USAGE_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_VM_STORAGE_USAGE_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_VM_STORAGE_USAGE', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_VM_VCPU', 'VMWP_VM_VCPU_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_VM_VCPU', 'VMWP_VM_VCPU_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_VM_VCPU_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_VM_VCPU', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'VMWARE_PERF_WATTS', 'VMWP_WATTS_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'VMWARE_PERF_WATTS', 'VMWP_WATTS_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE VMWP_WATTS_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'VMWARE_PERF_WATTS', cascade => TRUE);

DBMS_OUTPUT.put_line('Completed conversion of reference tables');

DBMS_OUTPUT.put_line('Starting Index creation');

--vmware_perf_sample -- 	
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_S_SAMPLE_TIME
ON VMWARE_PERF_SAMPLE ("SAMPLE_TIME")';
	
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_S_VMOID_SAMPLE_TIME
ON VMWARE_PERF_SAMPLE ("VMWARE_OBJECT_ID","SAMPLE_TIME")';

-- VMWARE_PERF_AGGREGATE --
-- no indexes necessary

-- VMWARE_PERF_CLUSTER --
-- no indexes necessary

-- VMWARE_PERF_DATASTORE_USAGE --
-- no indexes necessary

-- VMWARE_PERF_DATASTORE_VM_USAGE--
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_D_SAMPLE_ID
ON VMWARE_PERF_DATASTORE_VM_USAGE ("SAMPLE_ID")';

-- VMWARE_PERF_DISK_RATE --
-- no indexes necessary
	
-- VMWARE_PERF_ENTITLEMENT --
-- no indexes necessary	
	
-- VMWARE_PERF_HOST_CPU --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_HC_SAMPLE_ID
ON VMWARE_PERF_HOST_CPU ("SAMPLE_ID")';

-- VMWARE_PERF_HOST_DISK_IO --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_HD_SAMPLE_ID
ON VMWARE_PERF_HOST_DISK_IO ("SAMPLE_ID")';

-- VMWARE_PERF_HOST_DISK_IO_ADV --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_HDA_SAMPLE_ID
ON VMWARE_PERF_HOST_DISK_IO_ADV ("SAMPLE_ID")';

-- VMWARE_PERF_HOST_Network --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_HN_SAMPLE_ID
ON VMWARE_PERF_HOST_NETWORK ("SAMPLE_ID")';

-- VMWARE_PERF_HOST_POWER_STATE --
-- no indexes necessary

-- VMWARE_PERF_MEM --
-- no indexes necessary

-- VMWARE_PERF_MEM_ADVANCED -- 
-- no indexes necessary

-- VMWARE_PERF_NETWORK_RATE --
-- no indexes necessary

-- VMWARE_PERF_VM_CPU --
-- no indexes necessary

-- VMWARE_PERF_VM_DISK_IO --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_D_ADV_SAMPLE_ID
ON VMWARE_PERF_VM_DISK_IO ("SAMPLE_ID")';

-- VMWARE_PERF_VM_NETWORK --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_N_SAMPLE_ID
ON VMWARE_PERF_VM_NETWORK ("SAMPLE_ID")';

-- VMWARE_PERF_VM_POWER_STATE --
-- no indexes necessary

-- VMWARE_PERF_VM_STORAGE_USAGE --
-- no indexes necessary	

-- VMWARE_PERF_VM_VCPU --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_VM_V_SAMPLE_ID
ON VMWARE_PERF_VM_VCPU ("SAMPLE_ID")	';

-- VMWARE_PERF_WATTS --
-- no indexes necessary	

DBMS_OUTPUT.put_line('Completed index creation');

DBMS_OUTPUT.put_line('Drop temp vmwp_sample_par table');

EXECUTE IMMEDIATE 'DROP TABLE VMWP_SAMPLE_PAR CASCADE CONSTRAINTS PURGE';

DBMS_OUTPUT.put_line('End of v6 table partitioning');
else 
DBMS_OUTPUT.put_line('No partition table for v6 so skipping partitioning those tables');

end if;


if v7check = 1 then

DBMS_OUTPUT.put_line('Starting v7 table partitioning');

DBMS_REDEFINITION.Start_redef_table(USER, 'NET_DEVICE_PERF_SAMPLE', 'NET_DP_SAMPLE_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'NET_DEVICE_PERF_SAMPLE', 'NET_DP_SAMPLE_PAR');
-- Cleanup data --
DBMS_STATS.gather_table_stats(USER, 'NET_DEVICE_PERF_SAMPLE', cascade => TRUE);

DBMS_OUTPUT.put_line('net_device_perf_sample partitioned');

DBMS_OUTPUT.put_line('Creating Partition tables for reference partition tables (net_device_perf_* tables)');

EXECUTE IMMEDIATE 'CREATE TABLE "NET_DP_PING_PAR" ( 
"ID" NUMBER(20),
"AVERAGE_TIME" FLOAT(126),
"PERCENT_LOSS" FLOAT(126),
"SAMPLE_ID" NUMBER(20) NOT NULL,
CONSTRAINT "FK_NET_DEV_PING"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES NET_DEVICE_PERF_SAMPLE ("ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_NET_DEV_PING)';


EXECUTE IMMEDIATE 'CREATE TABLE "NET_DP_PORT_PAR" ( 
"ID" NUMBER(20),
"IF_INDEX" NUMBER(20),
"IF_OPER_STATUS" NUMBER(20),
"KBPS_IN_RATE" NUMBER(20),
"KBPS_OUT_RATE" NUMBER(20),
"KBPS_TOTAL_RATE" NUMBER(20),
"DISCARDS_IN_RATE" NUMBER(20),
"DISCARDS_OUT_RATE" NUMBER(20),
"DISCARDS_TOTAL_RATE" NUMBER(20),
"ERRORS_IN_RATE" NUMBER(20),
"ERRORS_OUT_RATE" NUMBER(20),
"ERRORS_TOTAL_RATE" NUMBER(20),
"USAGE_IN_PERCENT" NUMBER(10),
"USAGE_OUT_PERCENT" NUMBER(10),
"USAGE_PERCENT" NUMBER(10),
"SAMPLE_ID" NUMBER(20) NOT NULL,
CONSTRAINT "FK_NET_DEV_PORT"
FOREIGN KEY ("SAMPLE_ID")
REFERENCES NET_DEVICE_PERF_SAMPLE ("ID") VALIDATE ,
PRIMARY KEY (ID, SAMPLE_ID) VALIDATE )
PARTITION BY REFERENCE (FK_NET_DEV_PORT)';

DBMS_OUTPUT.put_line('Completed reference partition table creation');

DBMS_OUTPUT.put_line('Starting conversion of reference partition tables');

-- up.time 7.0 tables
DBMS_REDEFINITION.Start_redef_table(USER, 'NET_DEVICE_PERF_PING', 'NET_DP_PING_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'NET_DEVICE_PERF_PING', 'NET_DP_PING_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE NET_DP_PING_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'NET_DEVICE_PERF_PING', cascade => TRUE);


DBMS_REDEFINITION.Start_redef_table(USER, 'NET_DEVICE_PERF_PORT', 'NET_DP_PORT_PAR');
DBMS_REDEFINITION.finish_redef_table(USER, 'NET_DEVICE_PERF_PORT', 'NET_DP_PORT_PAR');
-- Cleanup data --
EXECUTE IMMEDIATE 'DROP TABLE NET_DP_PORT_PAR CASCADE CONSTRAINTS PURGE';
DBMS_STATS.gather_table_stats(USER, 'NET_DEVICE_PERF_PORT', cascade => TRUE);

DBMS_OUTPUT.put_line('Completed conversion of reference tables');

DBMS_OUTPUT.put_line('Starting Index creation');

-- NET_DEVICE_PERF_SAMPLE --
-- no indexes necessary	

-- NET_DEVICE_PERF_LATEST_SAMPLE --
-- no indexes necessary

-- NET_DEVICE_PERF_PING --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_ND_PING_SAMPLE_ID
ON NET_DEVICE_PERF_PING ("SAMPLE_ID")	';

-- NET_DEVICE_PERF_PORT --
EXECUTE IMMEDIATE 'CREATE INDEX UPTPAR_ND_PORT_SAMPLE_ID
ON NET_DEVICE_PERF_PORT ("SAMPLE_ID")';

DBMS_OUTPUT.put_line('Completed index creation');

DBMS_OUTPUT.put_line('Drop temp net_dev_perf_sample_par table');

EXECUTE IMMEDIATE 'DROP TABLE NET_DP_SAMPLE_PAR CASCADE CONSTRAINTS PURGE';

DBMS_OUTPUT.put_line('End of v7 table partitioning');
else 
DBMS_OUTPUT.put_line('No partition table for v7 so skipping partitioning those tables');

end if;

DBMS_OUTPUT.put_line('Create the procedure that can be used for rebuilding performance indexes');

end;
/

CREATE OR REPLACE PROCEDURE rebuild_uptime_indexes IS
	CURSOR cur_index IS
		SELECT index_name
		FROM user_indexes
		WHERE (table_name like 'PERFORMANCE_%'
		OR table_name like 'ERDC_%_DATA'
		OR table_name like 'RANGED_OBJECT_VALUE'
		OR table_name like 'VMWARE_PERF_%'
		OR table_name like 'NET_DEVICE_%')
		AND status = 'UNUSABLE';
BEGIN
	FOR line IN cur_index
	LOOP
		DBMS_OUTPUT.put_line('Rebuilding index ' || line.index_name);
		EXECUTE IMMEDIATE 'ALTER INDEX ' || line.index_name || ' REBUILD UNRECOVERABLE';
	END LOOP;
END rebuild_uptime_indexes;
/
